%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Press Release
% LaTeX Template
% Version 1.0 (2/6/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[11pt,pressrelease]{newlfm} % Font size

\usepackage{charter} % Use the Charter font for the document text
\usepackage{hyperref}
\usepackage{amsmath}


\newcounter{section}
\newcounter{subsection}[section]
\setcounter{secnumdepth}{3}
\makeatletter
\renewcommand\section{\@startsection {section}{1}{\z@}%
                                   {-3.5ex \@plus -1ex \@minus -.2ex}%
                                   {2.3ex \@plus.2ex}%
                                   {\normalfont\Large\bfseries}}
\newcommand\subsection{\@startsection{subsection}{2}{\z@}%
                                     {-3.25ex\@plus -1ex \@minus -.2ex}%
                                     {1.5ex \@plus .2ex}%
                                     {\normalfont\large\bfseries}}
\renewcommand \thesection{\@arabic\c@section}
\renewcommand\thesubsection{\thesection.\@arabic\c@subsection}

\makeatother


% \PhrPhone{Phone} % Customize the "Telephone" text
\PhrEmail{Email} % Customize the "E-mail" text
%\PhrContact{Contact} % Uncomment this line to change the 'Contact:' text

%----------------------------------------------------------------------------------------
%	PRESS RELEASE INFORMATION
%----------------------------------------------------------------------------------------

% \makeletterhead{Uiuc}{\Cheader{\vspace{16pt}\includegraphics[width=0.5\linewidth]{logo.png}}} % Include a company logo, if you don't use one you will need to uncomment line 6 in the prsrls.tex file
% \lthUiuc % Print the company/institution logo

\release{Cassowary PureScript Proposal} % When the press release may be used

\namefrom{Athan Clark} % Name

% \addrfrom{ % From address
% 123 Broadway \\
% City, State 12345
% }

% \phonefrom{(000) 111-1111} % Phone number
%
\emailfrom{athan.clark@gmail.com} % Email address

\headline{Pure Functional Programming for Total Correctness} % Headline for the press release

\newcommand{\subtitle}{The benefits of functional languages like PureScript for implementing complex,
mathematically dense concepts, like constraint solvers or compilers.} % Subtitle for the press release, if you don't want one just remove the subtitle text leaving the rest of the command

% \byline{\textbf{City, Country -- \today ~--} Summary/overview of facts including who, what, where, when as well as why the press should care enough to write about this.} % A summary line for the press release

%----------------------------------------------------------------------------------------

\begin{document}
\begin{newlfm}

%----------------------------------------------------------------------------------------
%	PRESS RELEASE CONTENT
%----------------------------------------------------------------------------------------

\begin{singlespace} % Uncomment for single line spacing

\section{Overview of Functional Programming}

It has been recently discovered that computer science is the
\href{http://ncatlab.org/nlab/show/relation+between+type+theory+and+category+theory}{heart of mathematics and logic}.
However, this is true only for functional programming languages like Haskell and PureScript -
they do away with the concept of a machine, and direct all attention to the concept of a
mathematical function. Programming then becomes the creation of logical specifications as types, and
functions as values, rather than sequentially manipulating physical data. I argue that this model
of programming is superior to the imperative style for the development and implementation of
complex mathematical algorithms, like constraint solvers and compilers.

\subsection{Correctness}

Through functional programming, you can be \textbf{guaranteed} software correctness. The insurance comes from
precise specifications as \textit{types}, bounding the derivable behavior of stateless functions. For
\href{http://ncatlab.org/nlab/show/Martin-L%C3%B6f+dependent+type+theory}{dependently typed languages}
(like Idris, Agda and Coq) if an
inconsistency is found, the program will simply not compile. In
\href{http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system}{Hindley-Milner type systems}
(like Haskell and PureScript), we can get a similar guarantee by \textit{generating test cases} by the hundreds, to
establish properties and conformance to logical propositions. These insurance techniques safeguard codebases far
more effectively than unit tests. By establishing \textit{algebraic properties} (such as associativity and
commutativity of expressions), we can \textbf{eliminate entire classes of bugs}
from being possible.

In the domain of implementing a constraint solver, for instance, we can be sure that our constraint set
is commutative - we can move constraints around in our set. Likewise, we can be sure that evaluating
and reducing our constraint set is also associative - we can evaluate in any direction. With
\href{http://hackage.haskell.org/package/constraints-0.4.1.3/docs/Data-Constraint.html#g:3}{entailment often as a first-class object},
we are free to prove logical propositions about our code, without much overhead or headache.

\subsection{Performance}

Functional languages like Haskell or PureScript find an elegant balance between formal correctness
and performance. By relying on purity - the lack of affecting reality - compilers are free to optimize at a
\textbf{macroscopic level}. This is evident in the premier Haskell compiler, GHC,
where you can get \href{http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf}{better SIMD performance} than hand and machine-optimized C.
Likewise, Warp (a web server written in Haskell) can achieve over
20,000 responses per second on a \$200 laptop (without optimizations enabled) compared to
Node.js getting only 600 rps on the same machine.

This is the remarkable effect of algebraic programming languages. By not relying on the real world,
we can condense our imaginary definition (soundly) to a much smaller idea, before giving it reigns
over reality.

\subsection{Clarity}

Purely functional languages produce more correct software and casually have greater performance, but
in addition to this, the are often smaller and more concise than their imperative counterparts.
With less room for human error and more ability to express ideas, writing algorithms like
\href{http://c2.com/cgi/wiki?QuickSortInHaskell}{quicksort} and
\href{http://lpaste.net/133831}{factorial} can be a brief couple lines of code.

\subsection{Examples}

The benefits of using such a language are obvious for any software project, \textit{especially}
when problems get complex.

\href{http://compcert.inria.fr/}{CompCert} is a C compiler (and compiler verification initiative),
similar to GCC, implemented in a functional programming language.
It's performance is almost as good as GCC's - about 80\%.
But remarkably, the size of the source code is minuscule:
CompCert is at about 60,000 lines of code - 50,000 dedicated to exhaustive proofs (verifying
correctness of binary translations on all supported architectures), with about 8000 lines
actually implementing the compiler. This is hardly a large codebase, especially compared
to the 15 million lines of code behind GCC.

Type inference algorithms are inherently constraint-oriented. For Hindley-Milner type systems,
the traditional approach is to use
\href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.7733&rep=rep1&type=pdf}{Algorithm W} -
recurse down the abstract syntax tree of an expression, populating a \"context\" with assumptions,
then merging the assumptions to a conclusion. In the GHC Haskell compiler, the act of instantiating
polymorphic type variables with actual instances (a mix of ad-hoc and parametric polymorphism),
\textit{is} constraint solving - in fact, we are given utilities to manipulate the notion of a
constraint
\href{http://hackage.haskell.org/package/constraints}{from within the language}.

In my \href{http://ltext.github.io}{\(\lambda\)text}
command-line utility, I've taken a variant of Algorithm W, directly oriented at
\href{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.9348}{constraint solving} to
implement type checking and type inference. There are approximately 1000 lines of
code in the entire project.

Less code \textit{may} mean less room for bugs, but the real reason for functional programming's
elegance is its underlying theory - one can directly translate category theory specifications to programs, or
formal proofs in propositional logic to types, in an identical syntax. Cryptol is a great
example of how someone can define cryptographic algorithms that mirror their algebraic specifications,
one-for-one.

\subsection{FP Conclusion}

In essence, if you are doing anything complicated, it is best to have a mathematical concept of
your problem. And if you have a mathematical definition of a problem, it is \textbf{trivial} to
implement the algorithm in a functional language, because of how closely it's tied to
the field. There have been
\href{https://wiki.haskell.org/Haskell_in_industry}{many successful projects} implemented in pure functional
programming languages - automated trading systems for the stock market, compilers and
interpreters, constraint solvers, and a wide array of mathematically dense algorithms.

Cassowary is a great example of an algorithm that has rich mathematical heritage, but has
grown rotten from neglect - it is extremely difficult to take a high-level, abstract concept
and implement it in an imperative setting. But, with the rise of pure functional programming,
I am confident that I can make a smaller, more correct, and more efficient implementation of the
Cassowary algorithm in PureScript for client-side browsers.

\section{Plans for New Cassowary}

Currently, all focus is being directed toward implementing the underlying engine - the augmented
simplex method, pivoting, etc. until everything logically works as expected. I already have
inequality expressions defined as an abstract syntax tree, and luckily the paper defines the
steps so clearly that it should be straightforward to manipulate these constructs to get the
correct result. When it is first implemented, it will be a PureScript DSL - we'll use
\(.+.\) as the addition operator, and \(.*.\) as the multiplication operator. Likewise,
we'll also have \(:==:\) and \(:<=:\) as operators to create inequalities. From there, it's
just a matter of taking the expressions and adding them to our constraint set. As a rough
outline for how the code would look from PureScript's perspective:

\begin{align*}
&mainConstraints :: Cassowary \enspace Subst&&\\
&mainConstraints = do&&\\
&\quad addConstr \enspace 0 \enspace \$ \enspace var \enspace ``x" \enspace .*. \enspace 5 \enspace :<=: var \enspace ``y"&&\\
&\quad addConstr \enspace 1 \enspace \$ \enspace var \enspace ``y" :=>: var \enspace ``z" \enspace .+. \enspace var ``x"&&\\
&\quad addConstr \enspace 1 \enspace \$ \enspace var \enspace ``x" \enspace :==: \enspace 10&&\\
&\quad subst \enspace \leftarrow \enspace inform \enspace [(x,10), (y,30)]&&\\
&\quad \ldots&&
\end{align*}

Where \(Cassowary\) is a stateful monad, \(addConstr\) takes a syntax tree of our expressions (and reduces them),
and \(inform\) populates some of the variables with data. I'm still not comfortable with deciding this as
how the api will look, but it is a rough estimate. Lastly, \(subst\) would be the resulting optimized substitution,
given the data we include. DSLs are an iconic feature of functional programming, and the style I've presented is
somewhat similar to the \href{http://leventerkok.github.io/sbv/}{bindings to CVC4 and Z3}.

In the example, the first parameter to \(addConstr\) is the weight associated with the constraint. Also,
\(inform\) is an alias for:

\[
inform \quad = \quad last \enspace <\$> \enspace zipWithM \enspace \big(
                    \lambda key \enspace val \rightarrow addConstr \enspace 1 \enspace \$
                    \enspace key \enspace :==: \enspace val \big) \enspace \circ \enspace unzip
\]

I'm unsure whether or not the structure will also form a comonad, for extraction. Many monads also form
comonads - including \(Reader\), \(Writer\) and \(State\), so it would not surprise me. Along the same line,
Walder et al.'s thesis on
\href{http://users.ugent.be/~tschrijv/Research/papers/monadic_cp_draft.pdf}{monadic constraint solving} appears
to also be a comonad. David Overton has also made a
\href{http://overtond.blogspot.com/2008/07/pre.html}{trivial constraint solver} with a different method to encoding
the constraints themselves, but will also be advised for inspiration. I will need to
do more formal specification before I can be confident in this estimate.

\(addConstr\) itself needs to reduce our expressions. Internally, the abstract syntax tree for our DSL will
look something like this:

\begin{flalign*}
&\mathrm{\textbf{data}} \enspace LinAst \enspace =\\
&\quad EVar \enspace String\\
&\quad ELit \enspace Double\\
&\quad ECoeff \enspace LinAst \enspace Double\\
&\quad ESum \enspace LinAst \enspace LinAst\\
\end{flalign*}

Where \(.+.\) is an alias for \(ESum\) and \(.*.\) for \(ECoeff\). Note that the right
side of \(ECoeff\) is a \(Double\) literal - this makes it impossible to construct quadratic \& higher
expressions.

From here, we would like to translate our user-level AST to standard form, to make the translation to
\textit{basic feasible solved form} easier - having a data type similar to:

\begin{flalign*}
&\mathrm{\textbf{data}} \enspace LinVar \enspace = \enspace LinVar\\
&\quad \{ \enspace varName \enspace :: \enspace String\\
&\quad , \enspace varCoeff \enspace :: \enspace Double \enspace \}\\
&\\
&\mathrm{\textbf{data}} \enspace LinExpr \enspace = \enspace LinExpr\\
&\quad \{ \enspace exprVars \enspace :: \enspace [LinVar]\\
&\quad , \enspace exprConst \enspace :: \enspace Double \enspace \}\\
\end{flalign*}

Where the list represents the summation of each variable, with it's coefficient. We will need a reduction /
translation function that turns our AST to a \(LinExpr\) - I'll refer to this as \(astToExpr\). I'll ommit
the definition for brevity - it's fairly routine; distribute \(ECoeff\) multiplications, combine \(ELit\)
constants, then fold over the AST to build a \textit{unique} \(LinExpr\). Constraint equations themselves
would look something like this:

\begin{flalign*}
&\mathrm{\textbf{data}} \enspace Constraint \enspace =\\
&\quad ConstrEqv \enspace LinExpr \enspace LinExpr\\
&\quad ConstrLte \enspace LinExpr \enspace LinExor\\
\end{flalign*}

Where \(:==:\) is an alias for \(\lambda x y \rightarrow ConstrEqv (astToExpr x) (astToExpr y)\), and likewise
for \(:<=:\). \(:=>:\) is just \(flip \enspace :<=:\). From here, we can build the actual constraint solver -
\(pivot\) does sound refactoring of \(LinExpr\)'s, then quasi-linear optimization would follow a similar technique
as augmented simplex form, annotated with error metrics, for each weight. I haven't implemented this yet, so
I can't give a definition.

\subsection{Backward Compatability}

I am very familiar with building raw JavaScript apis (I built a runtime typechecker for javascript
that uses chaining to implement partial application - see
\href{http://github.com/athanclark/frankenscript}{frankenscript}). To make a cassowary.js-compliant
api would be possible, but for me that is less important than making a PureScript implementation that works
well. Along this line of reasoning, I could also cater your desires for an end-user api to your liking,
but again this will have to be post-implementation.

\subsection{Proposal}

This will be an implementation of
\href{https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf}{Cassowary}
in PureScript, callable from JavaScript.
Extensive tests will be declared for this implementation, including \textbf{all tests} currently
satisfied in
\href{https://github.com/slightlyoff/cassowary.js/tree/master/tests}{the existing Cassowary.js implementation}.
Proof of this subsumption will be provided in detail as both a formal document, and a pluggable
architecture, so one can see first-hand that all tests are included.

Modifications may also be made to the Cassowary specification (in the paper referenced above) -
including its
\href{https://www.me.utexas.edu/~jensen/ORMM/supplements/methods/lpmethod/S1_dualsimplex.pdf}{Dual-Simplex Method}
orientation, potentially porting to an
\href{http://en.wikipedia.org/wiki/Mehrotra_predictor%E2%80%93corrector_method}{Interior-Point method}.
Likewise, some of the homogeneous matrix arithmetic may be offloaded to
\href{https://www.khronos.org/webcl/}{WebCL} or
\href{https://developer.mozilla.org/en-US/docs/Web/WebGL}{WebGL} depending on its feasibility
and improved performance.

I expect to have the working implementation completed in less than two weeks (by June 24th, 2015).
This implementation will include \textbf{all tests}, and will be correct. Likewise, there will be
efforts made to offload more difficult work to optimize the algorithm (via WebGL or WebCL as stated
above), but it is not guaranteed to solve a set of constraints, modified constraint, or appended
constraint in under 30 milliseconds on an average machine, although serious attempts will be made
to achieve this goal.

I have
\href{http://hackage.haskell.org/package/linear-grammar}{syntactic data structures implemented},
and almost have a pure, basic
\href{https://github.com/athanclark/simplex-basic}{Primal Simplex implementation} completed
(without SIMD enhancements) as of June 10th, 2015.

It has also been stated that the product will be released as open-source under an
\href{http://opensource.org/licenses/MIT}{MIT license} once it's complete.


\end{singlespace} % Uncomment for single line spacing

%----------------------------------------------------------------------------------------

\end{newlfm}
\end{document}
